<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° VIP ‚ö°</title>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">


    <style>
        /* Base Styles & Resets */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #0a0a0a; /* Deep dark background */
            color: #ffffff; /* White text for contrast */
            font-family: 'Poppins', sans-serif; /* Clean, modern font */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
            padding: 20px; /* Generous padding */
            overflow-x: hidden; /* Prevent horizontal scroll */
            background-image: radial-gradient(circle at center, #1a0000 0%, #0a0a0a 75%, #000000 100%); /* Subtle radial gradient */
        }

        /* Main Container */
        .container {
            width: 90%;
            max-width: 400px;
            padding: 25px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            animation: fadeIn 0.8s ease-out;
        }

        /* Animated Border Effect */
        .container::before {
            content: '';
            position: absolute;
            top: -3px; left: -3px; right: -3px; bottom: -3px;
            background: linear-gradient(45deg, #ff0000, #ff7b00, #ff00ff, #00ffff, #ff0000);
            background-size: 400% 400%;
            z-index: -1;
            border-radius: 15px;
            filter: blur(6px);
            animation: gradientBorder 8s ease infinite;
        }

        @keyframes gradientBorder {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Headings */
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 12px #ff3333, 0 0 25px #ff3333;
            margin-bottom: 20px;
            animation: pulseGlow 2s infinite alternate;
        }
        @keyframes pulseGlow {
            from { text-shadow: 0 0 15px #ff0000, 0 0 30px #ff0000; }
            to { text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000, 0 0 50px rgba(255, 0, 0, 0.8); }
        }

        h3 { /* For History/Stats Titles */
            font-family: 'Poppins', sans-serif;
            font-size: 20px;
            color: #ff6666;
            margin-top: 35px;
            margin-bottom: 15px;
            text-shadow: 0 0 8px rgba(255, 80, 80, 0.7);
            border-bottom: 1px solid rgba(255, 80, 80, 0.5);
            padding-bottom: 8px;
        }

        /* Input Fields */
        input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 2px solid #ff3333;
            border-radius: 8px;
            background: #1a1a1a;
            color: white;
            text-align: center;
            font-size: 17px;
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.6);
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            font-family: 'Roboto Mono', monospace;
        }
        input::placeholder {
            color: #bbb;
            opacity: 0.7;
        }
        input:focus {
            border-color: #ff6666;
            box-shadow: 0 0 15px rgba(255, 102, 102, 0.8);
        }

        /* Buttons */
        .login-button {
            width: 100%; 
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #ff3333;
            color: white;
            font-size: 19px;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.7);
            transition: background 0.3s, box-shadow 0.3s, transform 0.2s;
            font-weight: bold;
        }

        .login-button:hover {
            background: #cc0000;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.9);
            transform: translateY(-2px);
        }
        .login-button:active {
            transform: translateY(0);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        /* Error Message */
        .error {
            color: #ff6666;
            margin-top: 15px;
            display: none;
            font-size: 15px;
        }

        /* Prediction Page Transition */
        #prediction-page {
            display: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #prediction-page.show {
            opacity: 1;
        }

        /* Info Boxes (Period, Prediction, Numbers, Level) */
        .prediction-info {
            margin: 15px 0;
            font-size: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .prediction-info .box {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 15px 25px;
            font-size: 22px;
            font-weight: 700;
            border-radius: 8px;
            border: 2px solid;
            text-shadow: 0 0 8px;
            font-family: 'Roboto Mono', monospace;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4), 0 0 10px rgba(255, 0, 0, 0.2);
        }
        .prediction-info .box span.label {
            font-size: 14px;
            font-weight: 400;
            color: #cccccc;
            text-shadow: none;
            font-family: 'Poppins', sans-serif;
            text-transform: uppercase;
            flex-basis: auto;
            flex-shrink: 0;
            margin-right: 15px;
            text-align: left;
        }
        .prediction-info .box span.value {
            flex-grow: 1;
            text-align: right;
            font-size: 22px;
            color: inherit; 
        }


        /* Box Color Schemes */
        .period-box { 
            color: #ffff66; 
            border-color: #ffff66; 
            text-shadow: 0 0 8px #ffff66; 
            display: flex;
            flex-direction: column; /* Keep as column to easily center the single line */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            padding: 10px 15px; /* Reduced vertical padding for smaller box */
            order: -1;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4), 0 0 10px rgba(255, 0, 0, 0.2);
        }
        .period-box .label {
            display: none; /* Hide the label completely */
        }
        .period-box .value {
            font-family: 'Roboto Mono', monospace;
            font-size: 28px; /* Slightly larger for clarity in simpler format */
            font-weight: 700;
            color: inherit;
            text-shadow: inherit;
            margin: 0;
            padding: 0;
            line-height: 1;
            white-space: nowrap; /* Keep content on a single line */
            text-align: center; /* Ensure the text itself is centered */
            width: 100%; /* Make it take full width of its container for centering */
        }


        /* Corrected CSS for signal-big/small to handle internal span */
        .signal-box {
            display: flex;
            justify-content: space-between; /* This spreads PREDICTION and BIG/SMALL */
            align-items: center;
            width: 100%;
            padding: 15px 25px;
            font-size: 22px;
            font-weight: 700;
            border-radius: 8px;
            border: 2px solid;
            text-shadow: 0 0 8px;
            font-family: 'Roboto Mono', monospace;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4), 0 0 10px rgba(255, 0, 0, 0.2);
            gap: 10px; /* Space between flex items */
        }
        .signal-box .label {
            margin-right: auto; /* Push value to the right */
            text-align: left;
        }
        .signal-box .value {
            text-align: right; /* Align value to the right */
        }
        .signal-box.signal-big { color: #66ccff; border-color: #66ccff; text-shadow: 0 0 8px #66ccff; }
        .signal-box.signal-small { color: #ff9966; border-color: #ff9966; text-shadow: 0 0 8px #ff9966; }


        /* Modified .number-box to allow dynamic coloring */
        .number-box { 
            /* Common styles for number-box */
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 15px 25px;
            font-size: 22px;
            font-weight: 700;
            border-radius: 8px;
            border: 2px solid;
            text-shadow: 0 0 8px;
            font-family: 'Roboto Mono', monospace;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4), 0 0 10px rgba(255, 0, 0, 0.2);
        }

        /* New classes for specific number colors/gradients */
        .red-number-box {
            border-color: #ff3333; /* Red border */
            color: #ff3333; /* Red text */
            text-shadow: 0 0 8px #ff3333;
        }

        .green-number-box {
            border-color: #00ff00; /* Green border */
            color: #00ff00; /* Green text */
            text-shadow: 0 0 8px #00ff00;
        }

        .zero-gradient-box {
            border-color: #ff3333; /* Red border */
            background: linear-gradient(to right, #ff3333 50%, #800080 50%); /* Red and Purple gradient */
            color: #ffffff; /* White text for contrast */
            text-shadow: 0 0 8px #ffffff;
        }

        .five-gradient-box {
            border-color: #00ff00; /* Green border */
            background: linear-gradient(to right, #00ff00 50%, #800080 50%); /* Green and Purple gradient */
            color: #ffffff; /* White text for contrast */
            text-shadow: 0 0 8px #ffffff;
        }

        .level-box { color: #ff66ff; border-color: #ff66ff; text-shadow: 0 0 8px #ff66ff; }


        /* Action Buttons (Win/Loss) - HIDDEN */
        .action-buttons {
            display: none; /* Hide these buttons as reporting is now automatic */
        }
        
        /* Live Status Message */
        #live-status {
            font-size: 16px;
            font-weight: bold;
            color: #ccc;
            margin-top: 25px;
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.7);
        }

        /* Stats Box - Made official dark */
        .stats-box {
            background: #1a1a1a; /* Very dark background */
            border: 2px solid #333333; /* Darker, subtle border */
            border-radius: 12px;
            padding: 15px;
            margin-top: 25px;
            font-size: 1rem;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.6), 0 0 10px rgba(0, 0, 0, 0.4); /* Darker shadows */
            font-family: 'Poppins', sans-serif;
            color: #e0e0e0; /* Slightly lighter text for readability */
        }
        .stats-box p {
            color: #ffffff; /* Ensure "OVERVIEW" is white */
            margin-bottom: 10px;
            font-weight: 600;
        }
        .stats-box span {
            font-weight: 700;
            font-size: 1.3rem;
            text-shadow: 0 0 8px;
            font-family: 'Roboto Mono', monospace;
        }
        .stats-box .win-count { color: #00ff00; }
        .stats-box .loss-count { color: #ff3333; }
        .stats-box .rounds-played-count { color: #ffff00; } /* New class for rounds played */


        /* Winning Probability Bar (The "Batti") */
        .winning-probability-container {
            margin-top: 35px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid #00ff00; /* Green border */
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5); /* Green glow */
            overflow: hidden; /* For the progress bar fill */
            position: relative;
            height: 60px; /* Fixed height for the bar */
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px #00ff00;
        }

        .winning-probability-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(to right, #00b300, #00ff00); /* Green gradient fill */
            width: 0%; /* Controlled by JS */
            transition: width 0.5s ease-in-out;
            z-index: 1;
        }

        .winning-probability-text {
            position: relative;
            z-index: 2; /* Ensure text is above the fill */
        }

    </style>
</head>
<body>

    <div id="login-box" class="container">
        <h1>üîí ACCESS PREDICTOR üîí</h1>
        <input type="password" id="password" placeholder="Enter Your Key">
        <button class="login-button" onclick="checkLogin()">UNLOCK</button>
        <p class="error" id="error-message">Access Denied! Incorrect Key.</p>
    </div>

    <div id="prediction-page" class="container">
        <h1>VIP PREDICTION</h1>
        
        <div class="prediction-info">
            <div class="box period-box">
                <span class="value" id="current-period-display">Period: ------</span>
            </div>
            <div class="signal-box" id="prediction-signal-box"> 
                <span class="label">PREDICTION</span>
                <span class="value" id="prediction-signal-value">--</span>
            </div>
            <div class="box number-box">
                <span class="label">PREDICTED NUMBERS</span>
                <span class="value" id="predicted-numbers">--</span>
            </div>
            <div class="box level-box">
                <span class="label">STRATEGY LEVEL</span>
                <span class="value" id="current-level-display">1</span>
            </div>
        </div>
        
        <p id="live-status">Fetching new prediction...</p>

        <div class="action-buttons" style="display: none;"> 
            <button class="btn-win" id="win-button">REPORT WIN</button>
            <button class="btn-loss" id="loss-button">REPORT LOSS</button>
        </div>

        <div class="stats-box">
            <p>OVERVIEW</p>
            Total Wins: <span class="win-count" id="total-wins">0</span> | Total Losses: <span class="loss-count" id="total-losses">0</span> | Rounds Played: <span class="rounds-played-count" id="total-rounds-played">0</span>
        </div>

        <div class="winning-probability-container">
            <div class="winning-probability-fill" id="probability-fill"></div>
            <span class="winning-probability-text" id="probability-text">0%</span>
        </div>

    </div>

    <script>
        // --- Login System ---
        function checkLogin() {
            var pass = document.getElementById("password").value;
            if (pass === "Kalambhai786K") { // Correct password
                document.getElementById("login-box").style.display = "none";
                const predictionPage = document.getElementById("prediction-page");
                predictionPage.style.display = "block";
                setTimeout(() => predictionPage.classList.add('show'), 10);
                initializePredictor();
            } else {
                document.getElementById("error-message").style.display = "block";
            }
        }

        // --- Prediction Core Variables ---
        let currentBetLevel = 1;
        let totalWins = 0;
        let totalLosses = 0;
        let lastPredictedType = null; // Stores our prediction (BIG/SMALL) for the *previous* period
        let lastPredictedPeriod = null; // Stores the period number for which we made the last prediction

        let currentWinStreak = 0;
        let currentLossStreak = 0;
        let totalRoundsPlayed = 0; 
        
        const MAX_BET_LEVEL = 3; 
        const REVERSAL_LOSS_THRESHOLD = 2; 

        // --- API Endpoints ---
        const BDG88ZF_API_URL = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
        const AR_LOTTERY_API_URL = 'https://h5.ar-lottery01.com/api/Lottery/GetGameInfo'; // New API for actual results

        // BDG88ZF API Data (for making prediction)
        const BDG88ZF_REQUEST_DATA = {
            typeId: 1, 
            language: 0,
            random: "e7fe6c090da2495ab8290dac551ef1ed", 
            signature: "1F390E2B2D8A55D693E57FD905AE73A7", 
            timestamp: 0
        };

        // Function to determine the CSS class for the predicted number's box
        function getNumberColorClass(number) {
            const num = parseInt(number);
            if (isNaN(num)) return ''; // Default or no class if not a number

            switch (num) {
                case 0: return 'zero-gradient-box'; // 0: Red + half purple
                case 5: return 'five-gradient-box'; // 5: Green + half purple
                case 1:
                case 3:
                case 7:
                case 9: return 'green-number-box'; // 1,3,7,9: Green
                case 2:
                case 4:
                case 6:
                case 8: return 'red-number-box'; // 2,4,6,8: Red
                default: return ''; // Fallback
            }
        }

        // --- Fetch Actual Result from AR_LOTTERY_API_URL ---
        async function fetchActualResult(periodToFetch) {
            try {
                const timestamp = Date.now(); // Current timestamp
                const gameCode = 'WinGo_1M'; // As per your API link
                
                // IMPORTANT: The random and signature parameters from ar-lottery might be dynamic.
                // For a simple test, we'll use a fixed random/signature, but this might need adjustment
                // if their API requires dynamically generated ones.
                const response = await fetch(`${AR_LOTTERY_API_URL}?gameCode=${gameCode}&language=en&random=${timestamp}&signature=71E69BBEF93AF19817470967C9C342CD&timestamp=${timestamp}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Assuming the structure is similar to the screenshot: data.data.gameIssueList
                // We need to find the exact period's result.
                if (data && data.data && data.data.gameIssueList && data.data.gameIssueList.length > 0) {
                    // Try to find the result for the specific period we're looking for
                    // The API might return multiple issues; we need the one matching 'periodToFetch'
                    // The issueNumber from BDG88ZF is a number, from AR_Lottery it might be a string.
                    // We need to ensure types match for comparison or convert them.
                    const targetPeriodResult = data.data.gameIssueList.find(issue => 
                        String(issue.issueNumber) === String(periodToFetch)
                    );
                    
                    if (targetPeriodResult) {
                        const actualNumber = targetPeriodResult.resultNumber;
                        // Determine Big/Small based on actual number
                        let actualBigSmall = '';
                        if (actualNumber >= 0 && actualNumber <= 4) {
                            actualBigSmall = 'SMALL';
                        } else if (actualNumber >= 5 && actualNumber <= 9) {
                            actualBigSmall = 'BIG';
                        }
                        
                        console.log(`Actual result for period ${periodToFetch}: Number=${actualNumber}, Big/Small=${actualBigSmall}`);
                        return { number: actualNumber, bigSmall: actualBigSmall };
                    } else {
                        // If the exact period result isn't found, try to use the *most recent completed* period
                        // This is a common fallback if the specific period hasn't updated yet.
                        const latestCompletedIssue = data.data.gameIssueList[0]; // Assuming the first item is the most recent
                        if (latestCompletedIssue) {
                            const actualNumber = latestCompletedIssue.resultNumber;
                            let actualBigSmall = '';
                            if (actualNumber >= 0 && actualNumber <= 4) {
                                actualBigSmall = 'SMALL';
                            } else if (actualNumber >= 5 && actualNumber <= 9) {
                                actualBigSmall = 'BIG';
                            }
                            console.warn(`Specific period ${periodToFetch} not found. Using latest result from AR Lottery API: Period=${latestCompletedIssue.issueNumber}, Number=${actualNumber}, Big/Small=${actualBigSmall}`);
                            return { number: actualNumber, bigSmall: actualBigSmall, issueNumber: latestCompletedIssue.issueNumber };
                        } else {
                            console.warn(`No results found in AR Lottery API response for period ${periodToFetch}.`);
                            return null;
                        }
                    }
                } else {
                    console.warn('Invalid or empty response from AR Lottery API:', data);
                    return null;
                }

            } catch (error) {
                console.error("Error fetching actual result from AR Lottery API:", error);
                document.getElementById("live-status").innerText = "‚ö†Ô∏è ERROR: Could not fetch actual game result (CORS or Network).";
                return null;
            }
        }

        // --- Main Prediction and Auto-Counting Logic ---
        async function fetchNewPrediction() {
            document.getElementById("live-status").innerText = "üîÑ Fetching latest game data from BDG88ZF API...";
            // No need to disable buttons as they are now hidden

            try {
                // Step 1: Fetch prediction from BDG88ZF API
                BDG88ZF_REQUEST_DATA.timestamp = Math.floor(Date.now() / 1000); 
                const bdgResponse = await fetch(BDG88ZF_API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json;charset=UTF-8" },
                    body: JSON.stringify(BDG88ZF_REQUEST_DATA)
                });
                const bdgData = await bdgResponse.json();

                if (bdgData && bdgData.data && bdgData.data.issueNumber) {
                    const apiPeriod = bdgData.data.issueNumber;
                    
                    // Check if this is a new period before making a new prediction
                    if (currentPredictedPeriod === apiPeriod) {
                        document.getElementById("live-status").innerText = "‚è≥ Waiting for next period prediction...";
                        // Try to fetch actual result for the *previous* period if there was one
                        if (lastPredictedPeriod && lastPredictedType) {
                            await checkAndRecordOutcome(lastPredictedPeriod, lastPredictedType);
                        }
                        return; // Exit if it's the same period
                    }

                    // Store the current period as the last predicted period
                    const previousPredictedPeriod = lastPredictedPeriod;
                    const previousPredictedType = lastPredictedType;

                    currentPredictedPeriod = apiPeriod;
                    totalRoundsPlayed++; 

                    // Step 2: Make a new prediction for the current period
                    let predictedSignal;
                    if (currentLossStreak >= REVERSAL_LOSS_THRESHOLD) {
                        predictedSignal = (previousPredictedType === "BIG") ? "SMALL" : "BIG"; 
                        console.log(`SMART PREDICTION: Reversing signal due to ${currentLossStreak} consecutive losses. Predicted: ${predictedSignal}`);
                    } else {
                        const lastDigitOfPeriod = parseInt(apiPeriod.toString().slice(-1));
                        if (!isNaN(lastDigitOfPeriod)) {
                            predictedSignal = (lastDigitOfPeriod >= 0 && lastDigitOfPeriod <= 4) ? "SMALL" : "BIG";
                            console.log(`NORMAL PREDICTION: Last digit ${lastDigitOfPeriod}. Predicted: ${predictedSignal}`);
                        } else {
                            predictedSignal = Math.random() > 0.5 ? "BIG" : "SMALL"; 
                            console.log("FALLBACK PREDICTION: Invalid issueNumber. Falling back to random.");
                        }
                    }
                    
                    lastPredictedType = predictedSignal; // Store for next cycle's outcome check
                    lastPredictedPeriod = apiPeriod; // Store the period for which this prediction was made

                    // Generate a predicted number that matches the predicted signal
                    const predictedNumberDisplay = generateSimulatedNumber(predictedSignal);
                    
                    // Update UI for NEW prediction
                    setTimeout(() => { 
                        document.getElementById("current-period-display").innerText = `Period: ${apiPeriod.toString().slice(-6)}`; 
                        
                        const predictionSignalBox = document.getElementById("prediction-signal-box"); 
                        const predictionSignalValue = document.getElementById("prediction-signal-value");

                        predictionSignalBox.classList.remove('signal-big', 'signal-small');
                        if (predictedSignal === "BIG") {
                            predictionSignalBox.classList.add('signal-big');
                        } else {
                            predictionSignalBox.classList.add('signal-small');
                        }
                        predictionSignalValue.innerText = predictedSignal; 

                        const numberBoxElement = document.querySelector('.number-box');
                        const numberColorClass = getNumberColorClass(predictedNumberDisplay);

                        numberBoxElement.classList.remove('zero-gradient-box', 'five-gradient-box', 'green-number-box', 'red-number-box');
                        if (numberColorClass) {
                            numberBoxElement.classList.add(numberColorClass);
                        }
                        document.getElementById("predicted-numbers").innerText = predictedNumberDisplay; 
                        
                        document.getElementById("current-level-display").innerText = currentBetLevel;
                        
                        document.getElementById("live-status").innerText = `‚úÖ New Prediction Generated for Period ${apiPeriod.toString().slice(-6)}.`;
                        updateWinningProbabilityBar(); 
                        updateStatsDisplay(); 
                    }, 50); 
                    
                    // Step 3: Check and record outcome for the *PREVIOUS* period
                    // This happens *after* we've made and displayed the new prediction.
                    if (previousPredictedPeriod && previousPredictedType) {
                        await checkAndRecordOutcome(previousPredictedPeriod, previousPredictedType);
                    } else if (totalRoundsPlayed === 1 && !previousPredictedPeriod) {
                         // For the very first round, there's no previous prediction to check.
                         document.getElementById("live-status").innerText = `‚ú® First prediction generated. Waiting for result of Period ${apiPeriod.toString().slice(-6)}.`;
                    }

                } else {
                    document.getElementById("live-status").innerText = "‚ö†Ô∏è ERROR: BDG88ZF API data stream interrupted or invalid response. Retrying...";
                    console.error("BDG88ZF API Response Error: No data or invalid issueNumber", bdgData); 
                }
            } catch (error) {
                document.getElementById("live-status").innerText = "‚ö†Ô∏è NETWORK ERROR: Could not connect to BDG88ZF API. Please check your internet. Retrying...";
                console.error("BDG88ZF API Fetch Error:", error);
            }
        }

        // Function to check actual result and update stats
        async function checkAndRecordOutcome(periodToCheck, predictedTypeForPeriod) {
            document.getElementById("live-status").innerText = `üìä Checking result for Period ${periodToCheck.toString().slice(-6)}...`;
            const actualResult = await fetchActualResult(periodToCheck);

            if (actualResult) {
                // We also check if the period of the fetched result matches the period we predicted for.
                // This is important if AR Lottery API returns latest result instead of exact period.
                let outcome;
                if (actualResult.bigSmall === predictedTypeForPeriod) {
                    outcome = 'WIN';
                    totalWins++;
                    currentBetLevel = 1; // Reset level on win
                    currentWinStreak++;
                    currentLossStreak = 0;
                } else {
                    outcome = 'LOSS';
                    totalLosses++;
                    currentLossStreak++;
                    currentWinStreak = 0;
                    
                    if (currentBetLevel < MAX_BET_LEVEL) {
                        currentBetLevel++; 
                    } else {
                        currentBetLevel = 1; // Reset to 1 after max level loss
                    }
                }
                document.getElementById("live-status").innerText = `‚úÖ Outcome for Period ${periodToCheck.toString().slice(-6)}: ${outcome}!`;
                console.log(`Outcome for Period ${periodToCheck}: ${outcome}. Actual: ${actualResult.bigSmall}, Predicted: ${predictedTypeForPeriod}`);
            } else {
                document.getElementById("live-status").innerText = `‚ö†Ô∏è Could not get result for Period ${periodToCheck.toString().slice(-6)}. This period's outcome will not be counted automatically.`;
                console.warn(`Failed to get actual result for period ${periodToCheck}.`);
            }
            updateStatsDisplay();
            updateWinningProbabilityBar(); 
        }


        // Generate a single number that matches the predicted type (Big/Small)
        function generateSimulatedNumber(predictedType) {
            let num; 
            if (predictedType === "BIG") {
                num = [5, 6, 7, 8, 9][Math.floor(Math.random() * 5)];
            } else { // SMALL
                num = [0, 1, 2, 3, 4][Math.floor(Math.random() * 5)];
            }
            return `${num}`; 
        }

        // --- Winning Probability Bar ("Batti") Logic ---
        function updateWinningProbabilityBar() {
            const probabilityFill = document.getElementById('probability-fill');
            const probabilityText = document.getElementById('probability-text');
            let percentage = 0;

            if (currentLossStreak === 0) {
                percentage = 30; // Level 1: 30%
            } else if (currentLossStreak === 1) {
                percentage = 60; // Level 2: 60% (after 1 loss)
            } else if (currentLossStreak === 2) {
                percentage = 90; // Level 3: 90% (after 2 losses)
            } else if (currentLossStreak >= MAX_BET_LEVEL) { 
                percentage = 100; // "4th Level": 100%
            } else {
                percentage = 30; // Default for unexpected cases
            }
            
            probabilityFill.style.width = `${percentage}%`;
            probabilityText.innerText = `${percentage}%`;
        }


        function updateStatsDisplay() {
            document.getElementById('total-wins').innerText = totalWins;
            document.getElementById('total-losses').innerText = totalLosses;
            document.getElementById('total-rounds-played').innerText = totalRoundsPlayed; 
        }

        // This function is now mostly redundant as buttons are hidden, but kept for consistency
        function disableActionButtons(disabled) {
            // document.getElementById('win-button').disabled = disabled;
            // document.getElementById('loss-button').disabled = disabled;
        }

        // --- Initialization and Auto-Update ---
        function initializePredictor() {
            updateStatsDisplay();
            updateWinningProbabilityBar(); 
            // Fetch the first prediction immediately
            fetchNewPrediction(); 
            // Set interval for 1 minute (60 seconds) to fetch new predictions
            setInterval(fetchNewPrediction, 60 * 1000); 
        }
    </script>

</body>
</html>
